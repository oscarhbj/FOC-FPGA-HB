The top module takes in iq-ref and id-ref. Iq is the desired current going through the motor perpendicular to the stator (electrical). Iq and Id is two 16 bits signed vectors. they gets sent into a pi controller and converts it to a voltage refrence in the voltage dq frame. the inverse park transformation converts it to the alpha beta frame. here we have the current in a two axis frame. The point that we get here then gets converted to polar coordinates as svpwm works with an amplitude and a angle. This is done through the cordic algorithm. This algorithm estimates the angle and the amplitude by using some clever geometric properties in adding and subtracting the x and y axis from each other. (it works by rotating our original point towards 0 and counting up the rotations that has been done. the result will be a scaled amplitude along x (with a fixed scale) and a sum of rotations equal to our original angle. this cordic implementations uses a lut and 10 iterations. (the results are scaled to 16 bits angle and 16 bits unsigned amplitude.

The svpwm works by finding the hexant that we hare placed within. then taking the moulo so we get an angle between 0 and 60 degrees. this angle goes through a state machine that decides on how many clock cycles we should spend in each state. The svpwm sets the angle on the output signal by quickly changing between two active states where the sum of each vector will give the desired angle. The amplitude is chosen by changing between active and inactive states. (active states means that we have two colis with a positive (or negative) voltage and one coil with the oposite polarity so the current goes from the two first coild shrough the last one. The result is a pwm signal to controll a motor with a desired angle and amplitude.

for the sensing of the motor we use a adc (analog to digital converter). In FPGA_top we read from the adc in a ring fashon (fread signal 1, then 2 then 3... and replace the signal we have saved continiously. the adc senses the current going through the three couls (ia, ib, ic). the svpwm send a signal when a 0 period has just finished. this means that the newest results in our ring buffer should have been sampeled through a 0 period. this is then converted to the alpha beta frame by taking a clarke transformation. (the same frame as we used cordic on, but in current this time). this is then converted to the dq frame (following the rotor) by using a Park transformation. We now have iq_current, and id_current. This is sent to the Pi controllers with the target set by the user.

The angle is found by using a rotary encoder. This counts on two pulses offset by half a period. counting the signals will give us a accuracy of 1/4 of a period on this sensor. This results in giving us 20 000 different positions in a full 360 mechanichal turn, and it also gives us the direction of rotation. this number is scaled up so it spans 16 bits. To find 0 electrical degrees we hijacs the svpwm on reset and startup to send out a set amplitude and an angle of 0 degrees. this lets us find 0 and set a offset in our encoder. This angle is 0 electrical degrees, and in our case here we say that this 0 is also 0 mechanical degrees. This might not be beautiful (quite francly it is ugly) but this will work for now. 

The core consists of a iq and id ref value that the user sends in. it is also possible to override the inputs of iq and id and send it a electrical angle that gets sent in + a voltage. 
the svpwm takes in a 16 bit unsigned amplitude and a unsigned 16bits angle. for the svpwm amplitude we only care about bit with idx 14 to 3. max value 2048
